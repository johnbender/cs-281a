\documentclass[usletter]{article}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{test}
\usepackage{complexity}
\usepackage[margin=1.5in]{geometry}

\begin{document}

\makeheader{John Bender}
           {February 10, 2014}
           {1}
           {Midterm Examination}

\begin{enumerate}
  \item Given any languages $L_1, L_2 \in \NP$, prove that $L_1 \cup L_2 \in \NP$
    \begin{proof}
      We must show that there exists a polynomial time $M_3$ such that:

      \begin{align}
        x \in (L_1 \cup L_2) \iff \exists u.M_3(x,u) = 1
      \end{align}

      By the definition of \NP\ and the membership of both $L_1$ and $L_2$ in \NP\  we know that there exist two polynomial time Turing machines, $M_1$ and $M_2$, such that:

      \begin{align}
        x \in L_1 \iff \exists u.M_1(x,u) = 1 \\
        x \in L_2 \iff \exists u.M_2(x,u) = 1
      \end{align}

      Further by the definition of set union we have:

      \begin{align}
        L_1 \cup L_2 = \{ x : x \in L_1 \lor x \in L_2 \}
      \end{align}

      By (1.3) we can characterize the problem as follows:

      \begin{align}
        x \in L_1 \lor x \in L_2 \iff \exists u.M_1(x,u) = 1 \lor  M_2(x,u) = 1
      \end{align}

      In which case we can define $M_3$ to first try $x,u$ with $M_1$ and then $M_2$ if necessary. Since both $M_1$ and $M_2$ are polynomial time executing them in sequence is also polynomial time, thus $M_3$ is a polynomial time Turing machine that verifies for $L_1 \cup L_2$.


    \end{proof}

    \newpage

  \item Let $f : \mathbb{N} \rightarrow \mathbb{N}$ and $g : \mathbb{N} \rightarrow \mathbb{N}$ be time-constructible. Prove that the following functions are also time-constructible: (a) $f + g$; (b) $f \cdot g$.
  \item Define $T : \mathbb{N} \rightarrow \mathbb{N}$ by $T(n) = max_{\alpha,x}\{T_{\alpha}(x) : T_{\alpha}(x) < \infty \}$, where $\alpha$ and $x$ range over all Boolean strings of length at most $n$, and $T_{\alpha}(x)$ denotes the running time of $M_{\alpha}$ on $x$. Prove that no Turing machine can compute $T$.

    \begin{proof}
      We assume $T$ is computable for the sake of contradiction. Then there exists a Turing machine $M_T$ that computes $T$. Further, there exists a binary string representation $\lfloor M_T \rfloor$ for $M_T$ of bounded length (TODO cite lemma/proof from book?).

      Next we select $n$ of sufficient length such that $T(n)$ must consider a Turing machine $M_{\beta}$ that accommodates the definition of $M_T$ and takes the following steps for an input $x \in \{0,1\}^n$:
      \begin{enumerate}
        \item Simulate $M_T$ on input $n = |x|$, obtaining the maximum running time of all Turing machines $M$ of length $n$.
        \item Write ones to a work tape recording the number written until it exceeds the value of the simulation of $M_T$ with $n$.
      \end{enumerate}

      Now, the result for $n$ must be $T(n) = T_{\beta}(x)$ for $|x| = n$ but then $T_{\beta}(x) > T(|x|)$ by (b), a contradiction.

    \end{proof}

  \item Consider the following task: given the encoding $\alpha \in \{0,1\}^*$ of a Turing machine $M_{\alpha}$ that halts on every input, determine whether $M_{\alpha}$ runs in constant time. Either give an algorithm for this problem or prove that it is undecidable.

      \begin{proof}
        For the sake of contradiction we assume there exists a deterministic Turing machine $M_{const}$ that decides the following language, where all $M_{\alpha}$ under consideration are known to halt.
        \begin{align}
          \{ \lfloor M_{\alpha} \rfloor : M_{\alpha} \text{runs in constant time} \}
        \end{align}

        Since it is possible to encode $M_{const}$ we construct $M_{\beta}$ using $M_{const}$ to take the following steps:

        \begin{enumerate}
          \item Simulate $M_{const}(\lfloor M_{const} \rfloor)$ and record the running time.
          \item If $M_{const}(\lfloor M_{const} \rfloor) = 1$ then we know that $M_{const}$ is a constant time algorithm and we simulate its execution with the input $x$.
          \item If $M_{const}(x) = 1$, write $|x|^2$ ones to a work tape and exit, otherwise exit having used a constant amount of time (by b) to run $M_{const}$ twice..
          \item Otherwise if $M_{const}(\lfloor M_{const} \rfloor) = 0$ then we know that $M_{const}$ is not a constant time algorithm, but since $M_{const}$ is a deterministic Turing machine this simulated execution has a fixed execution time $T_{const}(n)$. We simulate its execution with the input $x$ and record the running time.
          \item If $M_{const}(x) = 1$ exit having run the non-constant time $M_{const}$ twice. Otherwise write ${3 \cdot T_{const}(n)}$ ones to a work tape which is both constant and by definition must exceed the execution time of $M_{const}(\lfloor M_{const} \rfloor)$.
        \end{enumerate}

        By assumption $M_{const}(\lfloor M_{\beta} \rfloor) = 1$ if $M_{\beta}$ is a constant time algorithm and $0$ if it isn't.

        Note $M_{\beta}$ halts for all inputs.
      \end{proof}

    \item Prove that at least one of the containments $\P \subseteq \PSPACE \subseteq \EXP$ is proper.

      \begin{proof}
        To show that $\P \subset \PSPACE$ we must show that for all languages $L_1 \in \P$ that also $L_1 \in \PSPACE$ and we must exhibit at least one language $L_2 \in \PSPACE$ that is not in $\P$.

        By the definition of $\P$ we know there must exist a Turing machine $M_1$ that decides $L_1$ in polynomial time $p(n)$. Also, by the definition of $\PSPACE$, any Turing machine $M_1$ that decides a language $L_1$ must do so in polynomial space. Then the first requirement is immediate since any $M_1$ running in polynomial time $p(n)$ can write to at most $p(n)$ cells if it does nothing else. So we have that $\P \subseteq \PSPACE$.

        To finish we note that the language TQBF $\in \PSPACE$

        TODO cite notes/book for tqbq
      \end{proof}

    \item Show that if $\PH = \PSPACE$, then the polynomial hierarchy collapses.

    \item Prove that $\P^{\text{TQBF}} = \NP^{\text{TQBF}}$.

      \begin{proof}
        We show that $\P^{\text{TQBF}} \subseteq \NP^{\text{TQBF}}$ and $\NP^{\text{TQBF}} \subseteq \P^{\text{TQBF}}$.

        First, by the definition of $\NP^{\text{TQBF}}$, for all $L \in \NP^{\text{TQBF}}$ there must be a TM $M$ with the ability to consult a $\text{TQBF}$ oracle such that:

      \begin{align}
        x \in L \iff \exists u.M(x,u) = 1
      \end{align}

      Clearly any member of $\P^{\text{TQBF}}$ is also a member of $\NP^{\text{TQBF}}$ since any TM $M'$ deciding a language in $\P^{\text{TQBF}}$ can simply ignore the certificate argument and decide membership as normal. So we have that, $\P^{\text{TQBF}} \subseteq \NP^{\text{TQBF}}$.

      Second, by Cook Levin we know that any language in $\NP^{\text{TQBF}}$ can be reduced to SAT in polynomial time. We also know that a linear time transformation to \text{TQBF} exists for any $\psi \in$ SAT by appending existential quantifiers to the front of $\psi$. Then an appeal to the TQBF oracle can be made resulting in a polynomial time algorithm and we have that $\NP^{\text{TQBF}} \subseteq \P^{\text{TQBF}}$.

      TODO Show that $\NP^{\text{TQBF}}$ is not significantly different from $\NP$ so that Cook Levin still applies.

      \end{proof}



\end{enumerate}

\end{document}
