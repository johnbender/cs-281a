
\documentclass[usletter]{article}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{test}
\usepackage{complexity}
\usepackage[margin=1.5in]{geometry}

\begin{document}

\makeheader{John Bender}
           {February 10, 2014}
           {1}
           {Midterm Examination}

\begin{enumerate}
  \item Given any languages $L_1, L_2 \in \NP$, prove that $L_1 \cup L_2 \in \NP$
    \begin{proof}
      We must show that there exists a polynomial time $M_3$ such that:

      \begin{align}
        x \in (L_1 \cup L_2) \iff \exists u.M_3(x,u) = 1
      \end{align}

      By the definition of \NP\ and the membership of both $L_1$ and $L_2$ in \NP\  we know that there exist two polynomial time Turing machines, $M_1$ and $M_2$, such that:

      \begin{align}
        x \in L_1 \iff \exists u.M_1(x,u) = 1 \\
        x \in L_2 \iff \exists u.M_2(x,u) = 1
      \end{align}

      Further by set union we have:

      \begin{align}
        x \in L_1 \lor x \in L_2 \iff \exists u.M_1(x,u) = 1 \lor  M_2(x,u) = 1
      \end{align}

      In which case we can define $M_3$ to first try $x,u$ with $M_1$ and then $M_2$ if necessary. Since both $M_1$ and $M_2$ are polynomial time executing them in sequence is also polynomial time, thus $M_3$ is a polynomial time Turing machine that verifies for $L_1 \cup L_2$.
    \end{proof}

  \item Let $f : \mathbb{N} \rightarrow \mathbb{N}$ and $g : \mathbb{N} \rightarrow \mathbb{N}$ be time-constructible. Prove that the following functions are also time-constructible: (a) $f + g$; (b) $f \cdot g$.


    \begin{proof} (a)
      We must show that the following $h : \mathbb{N} \rightarrow \mathbb{N}$ is time-constructible.

      \begin{align*}
        h(n) &= f(n) + g(n)
      \end{align*}

      That is, we must show there exists a Turing machine $M_h$ that computes $\lfloor f(|x|) + g(|x|) \rfloor$ in $O(f(n) + g(n))$ for $x \in \{0,1\}^n$.

      We know the following:

      \begin{itemize}
        \item Any time-constructible function $T(n)$ must be at least $n$ to read the input.

        \item There exists a Turing machine $M_f$ that computes $\lfloor f(|x|) \rfloor$ in $O(f(n))$ by the definition of time-constructibility.

        \item There exists a Turing machine $M_g$ that computes $\lfloor g(|x|) \rfloor$ in $O(g(n))$.

        \item Either $f = O(g)$, $g = O(f)$ or $f = \Theta(g)$.

        \item Adding two binary numbers can be done in linear time.
      \end{itemize}

      As a result we know that a TM $M_h$ computing $h(n)$ will be $\Theta(f(n))$ or $\Theta(g(n))$, in other words $M_h$ can safely emulate both $M_f$ and $M_g$ and remain $O(f(n) + g(n))$.
    \end{proof}

    \begin{proof} (b)
      We must show that the following $h : \mathbb{N} \rightarrow \mathbb{N}$ is time-constructible.

      \begin{align*}
        h(n) &= f(n) \cdot g(n)
      \end{align*}

      That is, we must show there exists a Turing machine $M_h$ that computes $\lfloor f(|x|) \cdot g(|x|) \rfloor$ in $O(f(n) \cdot g(n))$ for some $x \in \{0,1\}^n$.

      This could be different from addition, because multiplication of two numbers is a quadratic time operation. Luckily, since the desired running time of $h$ is $O(f(n) \cdot g(n))$ and we know that $f$ and $g$ must be at least linear, then $h = \Omega(n^2)$, which accommodates the multiplication in the case where it dominates either $f$ or $g$.

      So our Turing machine $M_h$ simulates $M_f$ then $M_g$ and then multiplies the two results and we have shown that this is $O(f(n) \cdot g(n))$.

    \end{proof}

  \item Define $T : \mathbb{N} \rightarrow \mathbb{N}$ by $T(n) = max_{\alpha,x}\{T_{\alpha}(x) : T_{\alpha}(x) < \infty \}$, where $\alpha$ and $x$ range over all Boolean strings of length at most $n$, and $T_{\alpha}(x)$ denotes the running time of $M_{\alpha}$ on $x$. Prove that no Turing machine can compute $T$.

    \begin{proof}
      We assume $T$ is computable for the sake of contradiction. Then there exists a Turing machine $M_T$ that computes $T$. Further, there exists a binary string representation $\lfloor M_T \rfloor$.

      Next we select $n$ of sufficient length such that $T(n)$ must consider a Turing machine $M_{\beta}$ that accommodates the definition of $M_T$ and takes the following steps for an input $x \in \{0,1\}^n$:
      \begin{enumerate}
        \item Simulate $M_T$ on input $n = |x|$, obtaining the maximum running time of all Turing machines $M$ of length $n$.
        \item Write ones to a work tape recording the number written until it exceeds the value of the simulation of $M_T$ with $n$.
      \end{enumerate}

      Now, the result for $n$ must be $T(n) = T_{\beta}(x)$ for $|x| = n$ but then $T_{\beta}(x) > T(|x|)$ by (b), a contradiction.
    \end{proof}

  \item Consider the following task: given the encoding $\alpha \in \{0,1\}^*$ of a Turing machine $M_{\alpha}$ that halts on every input, determine whether $M_{\alpha}$ runs in constant time. Either give an algorithm for this problem or prove that it is undecidable.

      \begin{proof}
        For the sake of contradiction we assume there exists a deterministic Turing machine $M_{const}$ that decides the following language, where all $M_{\alpha}$ under consideration are known to halt.
        \begin{align}
          \{ \lfloor M_{\alpha} \rfloor : M_{\alpha} \text{runs in constant time} \}
        \end{align}

        Since it is possible to encode $M_{const}$ we construct $M_{\beta}$ using $M_{const}$ to take the following steps:

        \begin{enumerate}
          \item Simulate $M_{const}(\lfloor M_{const} \rfloor)$ and record the running time.
          \item If $M_{const}(\lfloor M_{const} \rfloor) = 1$ then we know that $M_{const}$ is a constant time algorithm and we simulate its execution with the input $x$.
          \item If $M_{const}(x) = 1$, write $|x|^2$ ones to a work tape and exit, otherwise exit having used a constant amount of time (by b) to run $M_{const}$ twice..
          \item Otherwise if $M_{const}(\lfloor M_{const} \rfloor) = 0$ then we know that $M_{const}$ is not a constant time algorithm, but since $M_{const}$ is a deterministic Turing machine this simulated execution has a fixed execution time $T_{const}(n)$. We simulate its execution with the input $x$ and record the running time.
          \item If $M_{const}(x) = 1$ exit having run the non-constant time $M_{const}$ twice. Otherwise write ${3 \cdot T_{const}(n)}$ ones to a work tape which is both constant and by definition must exceed the execution time of $M_{const}(\lfloor M_{const} \rfloor)$.
        \end{enumerate}

        By assumption $M_{const}(\lfloor M_{\beta} \rfloor) = 1$ if $M_{\beta}$ is a constant time algorithm and $0$ if it isn't.

        Note $M_{\beta}$ halts for all inputs.
      \end{proof}

    \item Prove that at least one of the containments $\P \subseteq \PSPACE \subseteq \EXP$ is proper.

      \begin{proof}
        By the transitivity of $\subseteq$ we have:

        \begin{equation}
          \P \subseteq \PSPACE \subseteq \EXP \implies \P \subseteq \EXP
        \end{equation}

        Which admits the possibility that $\P = \EXP$ which we know is not true by the time hierarchy theorem. Therefore, we must conclude that one of the two subsets must be proper as required.
      \end{proof}

    \item Show that if $\PH = \PSPACE$, then the polynomial hierarchy collapses.

      \begin{proof}
        We know that there exists a $\PSPACE$-complete problem, TQBF. Then, if $\PH = \PSPACE$, TQBF must also be $\PH$-complete. This implies that every problem in $\PH$ can be reduced in polynomial time to TQBF. Also, by the definition of $\PH$ then TQBF must also exist at a specific ``level'' of the polynomial hierarchy. As a result all languages in $\PH$ can be reduced to the level at which TQBF resides and the hierarchy collapses.
      \end{proof}

    \newpage

    \item Prove that $\P^{\text{TQBF}} = \NP^{\text{TQBF}}$.

      \begin{proof}
        We show that $\P^{\text{TQBF}} \subseteq \NP^{\text{TQBF}}$ and $\NP^{\text{TQBF}} \subseteq \P^{\text{TQBF}}$.

        First, by the definition of $\NP^{\text{TQBF}}$, for all $L \in \NP^{\text{TQBF}}$ there must be a TM $M$ with the ability to consult a $\text{TQBF}$ oracle such that:

      \begin{align}
        x \in L \iff \exists u.M(x,u) = 1
      \end{align}

      Clearly any member of $\P^{\text{TQBF}}$ is also a member of $\NP^{\text{TQBF}}$ since any TM $M'$ deciding a language in $\P^{\text{TQBF}}$ can simply ignore the certificate argument and decide membership as normal. So we have that, $\P^{\text{TQBF}} \subseteq \NP^{\text{TQBF}}$.

      Second, by Cook Levin we know that any language in $\NP^{\text{TQBF}}$ can be reduced to SAT in polynomial time. Then an appeal to the TQBF oracle can be made resulting in a polynomial time algorithm and we have that $\NP^{\text{TQBF}} \subseteq \P^{\text{TQBF}}$.

      Note, we can say that Cook Levin applies to $\NP^{\text{TQBF}}$

      \end{proof}

    \item Find an error in the following incorrect proof that $\NPSPACE = \PSPACE$ ...

      Due to non-determinism the algorithm can't know when it is done ``trying out all the possible non-deterministic guesses'' without doing some recording of which guesses it has made. This may require as much as $2^{n^c}$ space to record and possibly placing the algorithm in $\EXPSPACE$.

\end{enumerate}

\end{document}
